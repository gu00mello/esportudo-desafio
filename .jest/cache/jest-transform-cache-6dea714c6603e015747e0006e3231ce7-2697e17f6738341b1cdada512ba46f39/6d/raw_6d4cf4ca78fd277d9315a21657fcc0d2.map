{"version":3,"names":["domain","hasSetImmediate","setImmediate","module","exports","rawAsap","task","queue","length","requestFlush","flushing","index","capacity","flush","currentIndex","call","scan","newLength","parentDomain","process","require","active","nextTick"],"sources":["raw.js"],"sourcesContent":["\"use strict\";\n\nvar domain; // The domain module is executed on demand\nvar hasSetImmediate = typeof setImmediate === \"function\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including network IO events in Node.js.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Avoids a function call\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory excaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\nrawAsap.requestFlush = requestFlush;\nfunction requestFlush() {\n    // Ensure flushing is not bound to any domain.\n    // It is not sufficient to exit the domain, because domains exist on a stack.\n    // To execute code outside of any domain, the following dance is necessary.\n    var parentDomain = process.domain;\n    if (parentDomain) {\n        if (!domain) {\n            // Lazy execute the domain module.\n            // Only employed if the user elects to use domains.\n            domain = require(\"domain\");\n        }\n        domain.active = process.domain = null;\n    }\n\n    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`\n    // cannot handle recursion.\n    // `requestFlush` will only be called recursively from `asap.js`, to resume\n    // flushing after an error is thrown into a domain.\n    // Conveniently, `setImmediate` was introduced in the same version\n    // `process.nextTick` started throwing recursion errors.\n    if (flushing && hasSetImmediate) {\n        setImmediate(flush);\n    } else {\n        process.nextTick(flush);\n    }\n\n    if (parentDomain) {\n        domain.active = process.domain = parentDomain;\n    }\n}\n"],"mappings":"AAAA;;AAEA,IAAIA,MAAJ;AACA,IAAIC,eAAe,GAAG,OAAOC,YAAP,KAAwB,UAA9C;AAWAC,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AACA,SAASA,OAAT,CAAiBC,IAAjB,EAAuB;EACnB,IAAI,CAACC,KAAK,CAACC,MAAX,EAAmB;IACfC,YAAY;IACZC,QAAQ,GAAG,IAAX;EACH;;EAEDH,KAAK,CAACA,KAAK,CAACC,MAAP,CAAL,GAAsBF,IAAtB;AACH;;AAED,IAAIC,KAAK,GAAG,EAAZ;AAGA,IAAIG,QAAQ,GAAG,KAAf;AAIA,IAAIC,KAAK,GAAG,CAAZ;AAIA,IAAIC,QAAQ,GAAG,IAAf;;AAQA,SAASC,KAAT,GAAiB;EACb,OAAOF,KAAK,GAAGJ,KAAK,CAACC,MAArB,EAA6B;IACzB,IAAIM,YAAY,GAAGH,KAAnB;IAGAA,KAAK,GAAGA,KAAK,GAAG,CAAhB;IACAJ,KAAK,CAACO,YAAD,CAAL,CAAoBC,IAApB;;IAMA,IAAIJ,KAAK,GAAGC,QAAZ,EAAsB;MAGlB,KAAK,IAAII,IAAI,GAAG,CAAX,EAAcC,SAAS,GAAGV,KAAK,CAACC,MAAN,GAAeG,KAA9C,EAAqDK,IAAI,GAAGC,SAA5D,EAAuED,IAAI,EAA3E,EAA+E;QAC3ET,KAAK,CAACS,IAAD,CAAL,GAAcT,KAAK,CAACS,IAAI,GAAGL,KAAR,CAAnB;MACH;;MACDJ,KAAK,CAACC,MAAN,IAAgBG,KAAhB;MACAA,KAAK,GAAG,CAAR;IACH;EACJ;;EACDJ,KAAK,CAACC,MAAN,GAAe,CAAf;EACAG,KAAK,GAAG,CAAR;EACAD,QAAQ,GAAG,KAAX;AACH;;AAEDL,OAAO,CAACI,YAAR,GAAuBA,YAAvB;;AACA,SAASA,YAAT,GAAwB;EAIpB,IAAIS,YAAY,GAAGC,OAAO,CAACnB,MAA3B;;EACA,IAAIkB,YAAJ,EAAkB;IACd,IAAI,CAAClB,MAAL,EAAa;MAGTA,MAAM,GAAGoB,OAAO,CAAC,QAAD,CAAhB;IACH;;IACDpB,MAAM,CAACqB,MAAP,GAAgBF,OAAO,CAACnB,MAAR,GAAiB,IAAjC;EACH;;EAQD,IAAIU,QAAQ,IAAIT,eAAhB,EAAiC;IAC7BC,YAAY,CAACW,KAAD,CAAZ;EACH,CAFD,MAEO;IACHM,OAAO,CAACG,QAAR,CAAiBT,KAAjB;EACH;;EAED,IAAIK,YAAJ,EAAkB;IACdlB,MAAM,CAACqB,MAAP,GAAgBF,OAAO,CAACnB,MAAR,GAAiBkB,YAAjC;EACH;AACJ"}